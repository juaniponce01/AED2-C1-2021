10) 
Representación:
	Cola se representa con estr donde 
		estr es secuencia(α)
---		
Solución Informal:
	- toda secuencia es valida
---
Invariante de Representación:
	Rep:	estr	->	boolean
	(∀e: estr) Rep(e)	≡ true 
---
Función de abstracción:
	Abs:	estr	->	Cola	{Rep(e)}
	(∀e: estr) Abs(e) =obs c: Cola | (1)∧(2)
		donde: 
		(1)	≡	vacía?(c) = vacía?(e)
		(2)	≡	proximo(c) = prim(e)
		(3) ≡ desencolar(c) = fin(e)
---
Interfaz:
	Parámetros formales:
		Géneros:	α
		Función:
			Copiar(in a:α) -> res: α
			Pre ≡ {true}
			Post ≡ {res = a} 
			Complejidad: Θ(copy(a))
			Descripción: Función copia de α's.
			---
	Se explica con:	Cola
	Géneros:		Cola
	
	Operaciones básicas:
		vacia()	-> res: Cola
		Pre ≡ {true}
		Post ≡ {res =obs vacia}
		Complejidad: Θ(1)
		Descripción: Genera una Cola vacia
		---		
		encolar(in a: α, in/out c: Cola)
		Pre ≡ {c =obs c0}
		Post ≡ {c =obs encolar(a, c0)}
		Complejidad: Θ(copy(a))
		Descripción: Genera una Cola con un nuevo elemento "a"
		Aliasing: el elemento se encola por copia
		---
		tamaño(in c: Cola) -> res: nat
		Pre ≡ {true}
		Post ≡ {res =obs tamaño(c)}
		Complejidad: Θ(1)
		Descripción: Muestra la cantidad de elementos de una Cola
		---
	Algoritmos del módulo:
	iVacia() → res : cola(α)
		res -> Vacio() 
	---
		iVacio() → res : secu(α)
			res -> vacia() 
		---
	iEncolar(in/out c : cola(α), in a : α)
		c-> insertarAlFinal(c, a)
	---	
	iInsertarAlFinal(in/out s : secu(α), in : a : α)
		s -> s • a
		//•(es el de insertar al final)
	---
	iEsVacia?(in c : cola(α)) -> res: bool
		res -> vacio?(c)
	---
		ivacio?(in s : secu(α)) -> res: bool
			res -> vacia?(s)
		---
	iProximo(in c : cola(α)) -> res : α
		res -> obtenerPrimero(c)
	---
		iobtenerPrimero(in s : secu(α))) -> res : α
			res -> prim(s)
		---
	iDesencolar(in/out c : cola(α))
		c -> sacarPrimero(c)
	---
		isacarPrimero(in/out s: secu(α))
			s -> fin(s)
		---
	iTamaño(in c : cola(α)) → res : nat
		res -> longitud(c)
	---
		ilongitud(in s : secu(α)) → res : nat
			res -> long(s)
		---
		

11) 
Representación:
	Conjunto se representa con estr donde 
		estr es secuencia(α)

Solución Informal:
	- la secuencia no puede tener repetidos
---
Invariante de Representación:
	Rep:	estr	->	boolean
	(∀e: estr) Rep(e)	≡ true ⇐⇒ (1)
	donde:
	(1) ≡ noHayRepetidos(e)
---
Función de abstracción:
	Abs:	estr	->	Conjunto	{Rep(e)}
	(∀e: estr) Abs(e) =obs c: Conjunto | (1)
		donde: 
		(1)	≡	(∀ a: α)(a ∈ c ⇒L está?(a, e))
---
Interfaz:
	Parámetros formales:
		Géneros:	α
		Función:
			Copiar(in a:α) -> res: α
			Pre ≡ {true}
			Post ≡ {res = a} 
			Complejidad: Θ(copy(a))
			Descripción: Función copia de α's.
			---
	Se explica con: Conjunto
	Géneros:		conj(α)
	
	Operaciones básicas:
		Ø()	-> res: conj(α)
		Pre ≡ {true}
		Post ≡ {res =obs Ø}
		Complejidad: Θ(1)
		Descripción: Genera un conjunto vacio
		Aliasing: No presenta aspectos de aliasing.
		---
		Ag(in a: α, in/out c: conj(α))
		Pre ≡ {c =obs c0}
		Post ≡ {c =obs Ag(a, c0)}
		Complejidad: Θ(copy(a))
		Descripción: Agrega un elemento al conjunto
		Aliasing: el elemento se agrega por copia
		
		---		
	Algoritmos del módulo:
		iØ() -> res: secu(α)
			res ← <>
		---
		iAg(in a: α, in/out c: secu(α))
			if ¬está?(a, c) then
				c ← a • c
			end if
    ---


12)
Representación:
	ConjEnRango se representa con estr donde 
		estr es ad(α)

Solución Informal:
	- todo elemento debe ser mayor al elemento del primer indice
	- todo elemento debe ser menor al elemento del ultimo indice 
---
Invariante de Representación:
	Rep:	estr	->	boolean
	(∀e: estr) Rep(e)	≡ true ⇐⇒ (1)∧(2)
		donde: 
		(1)	≡	(∀ a: α)(definido?(e, a) ⇒L e[0] ≤ a)
		(2)	≡	(∀ a: α)(definido?(e, a) ⇒L e[tam(e)-1] ≥ a)
---
Función de abstracción:
	Abs:	estr	->	ConjEnRango	{Rep(e)}
	(∀e: estr) Abs(e) =obs c: ConjEnRango | (1)∧(2)∧(3)
		donde: 
		(1)	≡	(∀ a: α)(definido?(e, a) ⇒L a ∈ c)
		(2)	≡	lower(c) = e[0]
		(3) ≡ upper(c) = e[tam(e)-1]
---
Interfaz:
	Parámetros formales:
		Géneros:	α
		Función:
			Copiar(in a:α) -> res: α
			Pre ≡ {true}
			Post ≡ {res = a} 
			Complejidad: Θ(copy(a))
			Descripción: Función copia de α's.
			---
	Se explica con:	ConjEnRango
	Géneros:		ConjEnRango
	
	Operaciones básicas:
		Ø(in n: nat, in m: nat)	-> res: ConjEnRango
		Pre ≡ {n ≤ m}
		Post ≡ {res =obs Ø}
		Complejidad: Θ(1)
		Descripción: Genera un conjEnRango vacio
		Aliasing: No presenta aspectos de aliasing.
		---		
		Ag(in a: nat, in c: conjEnRango)	-> res: ConjEnRango
		Pre ≡ {c =obs c0 ∧L lower(c0) ≤ a ≤ upper(c0)}
		Post ≡ {c =obs Ag(a, c0)}
		Complejidad: Θ(copy(a))
		Descripción: Agrega un elemento al conjEnRango
		Aliasing: el elemento "a" se agrega por copia.
		---
	Algoritmos del módulo:
		iØ(in n: nat, in m: nat) -> res: ad(α)
			res ← crearArreglo(m-n+1)
			res[0] ← n
			res[tam(res)-1] ← m
		---
		iAg(in n: nat, in/out a: ad(α))
			a[n - a[0]] ← n
		---


13)
Representación:
	ConjAjust se representa con estr donde 
		estr es tupla ⟨ conjunto:	conj(nat),
									  lower: nat, 
									  upper: nat ⟩

Solución Informal:
	- lower y upper pertenecen al conjunto
	- lower es menor o igual a upper
	- debe haber mas elementos que se encuentren en el rango que fuera de el
---
Invariante de Representación:
	Rep:	estr	->	boolean
	(∀e: estr) Rep(e)	≡ true ⇐⇒ (1)∧(2)∧(3)
		donde: 
		(1)	≡	e.lower, e.upper ∈ e.conjunto
		(2)	≡	e.lower ≤ e.upper
		(3) ≡ #(e.conjunto - elemsEnRango(e.conjunto, e.lower, e.upper)) ≤ #(elemsEnRango(e.conjunto, e.lower, e.upper))
		
			donde:
			elemsEnRango: conj(nat) × nat × nat -> conj(nat)
			elemsEnRango(c, l, u) ≡ 
			if Ø?(c) then
				Ø
			else
				if l ≤ dameUno(c) ≤ u then
					Ag(dameUno(c), elemsEnRango(sinUno(c), l, u))
				else
					elemsEnRango(sinUno(c), l, u)
				fi
			fi
---
Función de abstracción:
	Abs:	estr	->	ConjAjust	{Rep(e)}
	(∀e: estr) Abs(e) =obs c: ConjAjust | (1)∧(2)∧(3)
		donde: 
		(1)	≡	(∀ a: α)(a ∈ e.conjunto ⇒L a ∈ c)
		(2)	≡	lower(c) = e.lower
		(3) ≡ upper(c) = e.upper
---
Interfaz:
	Parámetros formales:
		Géneros:	α
		Función:
			Copiar(in a:α) -> res: α
			Pre ≡ {true}
			Post ≡ {res = a} 
			Complejidad: Θ(copy(a))
			Descripción: Función copia de α's.
			---
	Se explica con:	ConjAjust
	Géneros:		ConjAjust
	
	Operaciones básicas:
		Ø(in n: nat, in m: nat)	-> res: ConjAjust
		Pre ≡ {n ≤ m}
		Post ≡ {res =obs Ø}
		Complejidad: Θ(1)
		Descripción: Genera un ConjAjust vacio
		Aliasing: No presenta aspectos de aliasing.
		---		
		Ag(in a: nat, in c: ConjAjust)	-> res: ConjAjust
		Pre ≡ {c =obs c0 ∧L lower(c0) ≤ a ≤ upper(c0)}
		Post ≡ {c =obs Ag(a, c0)}
		Complejidad: Θ(copy(a))
		Descripción: Agrega un elemento al ConjAjust
		Aliasing: el elemento "a" se agrega por copia.
		---		
	Algoritmos del módulo:
		iØ(in n: nat, in m: nat) -> res: estr
			res ← ⟨{n, m}, n, m⟩
		---
		iAg(in n: nat, in/out e: estr)
			if #(e.conjunto - elemsEnRango(e.conjunto, e.lower, e.upper)) < #(elemsEnRango(e.conjunto, e.lower, e.upper)) then
				e.conjunto ← Ag(n, e.conjunto)
			end if
		---
			ielemsEnRango(in c: conj(nat), in l: nat, in u: nat) -> res: conj(nat)
				if Ø?(c) then
					res ← Ø
				else
					if l ≤ dameUno(c) ≤ u then
						res ← Ag(dameUno(c), elemsEnRango(sinUno(c), l, u))
					else
						res ← elemsEnRango(sinUno(c), l, u)
					end if
				end if
